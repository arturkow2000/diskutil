use crate::{u8_array_uninitialized, Error, Result};
use std::convert::TryInto;
use std::fmt;
use std::io::{Cursor, Read, Seek, SeekFrom, Write};

pub struct DynamicHeader {
    pub data_offset: u64,
    pub bat_offset: u64,
    pub header_version: u32,
    pub max_table_entries: u32,
    pub block_size: u32,
    pub parent_unique_id: [u8; 16],
    pub parent_timestamp: u32,
    pub reserved: u32,
    pub parent_unicode_name: [u8; 512],
    pub parent_locator_entry_1: [u8; 24],
    pub parent_locator_entry_2: [u8; 24],
    pub parent_locator_entry_3: [u8; 24],
    pub parent_locator_entry_4: [u8; 24],
    pub parent_locator_entry_5: [u8; 24],
    pub parent_locator_entry_6: [u8; 24],
    pub parent_locator_entry_7: [u8; 24],
    pub parent_locator_entry_8: [u8; 24],
    pub reserved2: [u8; 256],
}

impl DynamicHeader {
    pub const SIZE: usize = 1024;

    pub fn decode(buffer: &[u8]) -> Result<Self> {
        debug_assert_eq!(buffer.len(), Self::SIZE);

        let mut reader = Cursor::new(buffer);
        let mut temp_buffer = u8_array_uninitialized!(16);
        let mut computed_checksum = 0u32;

        let compute_checksum = |checksum: &mut u32, b: &[u8]| {
            for x in b.iter().copied() {
                *checksum = checksum.wrapping_add(x.into())
            }
        };

        macro_rules! read {
            (u8) => {{
                reader.read_exact(&mut temp_buffer[..1])?;
                compute_checksum(&mut computed_checksum, &temp_buffer[..1]);
                temp_buffer[0]
            }};
            ($type:ty) => {{
                let s = &mut temp_buffer[..::std::mem::size_of::<$type>()];
                reader.read_exact(s)?;
                compute_checksum(&mut computed_checksum, s);
                <$type>::from_be_bytes((*s).try_into().unwrap())
            }};
            ($type:ty, native) => {{
                let s = &mut temp_buffer[..::std::mem::size_of::<$type>()];
                reader.read_exact(s)?;
                compute_checksum(&mut computed_checksum, s);
                <$type>::from_ne_bytes((*s).try_into().unwrap())
            }};
            ($type:ty, nohash) => {{
                let s = &mut temp_buffer[..::std::mem::size_of::<$type>()];
                reader.read_exact(s)?;
                let z = [0u8; ::std::mem::size_of::<$type>()];
                compute_checksum(&mut computed_checksum, &z[..]);
                <$type>::from_be_bytes((*s).try_into().unwrap())
            }};
            ($size:expr) => {{
                let mut b = u8_array_uninitialized!($size);
                reader.read_exact(&mut b[..])?;
                compute_checksum(&mut computed_checksum, &b[..]);
                b
            }};
        }

        let cookie = read!(8);
        if &cookie != b"cxsparse" {
            return Err(Error::InvalidVhdDynamicHeader(Some(
                "invalid cookie".to_owned(),
            )));
        }

        let data_offset = read!(u64);
        let bat_offset = read!(u64);
        let header_version = read!(u32);
        let max_table_entries = read!(u32);
        let block_size = read!(u32);
        let checksum = read!(u32, nohash);
        let parent_unique_id = read!(16);
        let parent_timestamp = read!(u32);
        let reserved = read!(u32);
        let parent_unicode_name = read!(512);
        let parent_locator_entry_1 = read!(24);
        let parent_locator_entry_2 = read!(24);
        let parent_locator_entry_3 = read!(24);
        let parent_locator_entry_4 = read!(24);
        let parent_locator_entry_5 = read!(24);
        let parent_locator_entry_6 = read!(24);
        let parent_locator_entry_7 = read!(24);
        let parent_locator_entry_8 = read!(24);
        let reserved2 = read!(256);

        debug_assert_eq!(reader.position(), Self::SIZE as u64);

        computed_checksum = !computed_checksum;

        if checksum != computed_checksum {
            return Err(Error::InvalidVhdDynamicHeader(Some(format!(
                "Checksum mismatch, computed 0x{:08X} but the checksum is 0x{:08X}",
                computed_checksum, checksum
            ))));
        }

        Ok(Self {
            data_offset,
            bat_offset,
            header_version,
            max_table_entries,
            block_size,
            parent_unique_id,
            parent_timestamp,
            reserved,
            parent_unicode_name,
            parent_locator_entry_1,
            parent_locator_entry_2,
            parent_locator_entry_3,
            parent_locator_entry_4,
            parent_locator_entry_5,
            parent_locator_entry_6,
            parent_locator_entry_7,
            parent_locator_entry_8,
            reserved2,
        })
    }

    pub fn create_dynamic(bat_size: usize, block_size: usize) -> Self {
        Self {
            data_offset: 0xFFFFFFFFFFFFFFFFu64,
            bat_offset: 1536,
            header_version: 0x00010000,
            max_table_entries: bat_size.try_into().unwrap(),
            block_size: block_size.try_into().unwrap(),
            ..unsafe { ::std::mem::zeroed() }
        }
    }

    pub fn encode(&self, buf: &mut [u8]) {
        let mut cursor = Cursor::new(buf);
        let mut checksum: u32 = 0;

        let compute_checksum = |checksum: &mut u32, b: &[u8]| {
            for x in b.iter().copied() {
                *checksum = checksum.wrapping_add(x.into())
            }
        };

        macro_rules! write {
            ($data:expr, array) => {{
                compute_checksum(&mut checksum, $data);
                cursor.write_all($data).unwrap();
            }};
            ($data:expr) => {{
                let x = $data.to_be_bytes();
                compute_checksum(&mut checksum, &x);
                cursor.write_all(&x).unwrap();
            }};
        }

        write!(b"cxsparse", array);
        write!(self.data_offset);
        write!(self.bat_offset);
        write!(self.header_version);
        write!(self.max_table_entries);
        write!(self.block_size);
        let p = cursor.position();
        write!(0u32);
        write!(&self.parent_unique_id, array);
        write!(self.parent_timestamp);
        write!(self.reserved);
        write!(&self.parent_unicode_name, array);
        write!(&self.parent_locator_entry_1, array);
        write!(&self.parent_locator_entry_2, array);
        write!(&self.parent_locator_entry_3, array);
        write!(&self.parent_locator_entry_4, array);
        write!(&self.parent_locator_entry_5, array);
        write!(&self.parent_locator_entry_6, array);
        write!(&self.parent_locator_entry_7, array);
        write!(&self.parent_locator_entry_8, array);
        write!(&self.reserved2, array);

        debug_assert_eq!(cursor.position(), Self::SIZE as u64);

        checksum = !checksum;
        cursor.seek(SeekFrom::Start(p)).unwrap();
        write!(checksum);
    }
}

impl fmt::Display for DynamicHeader {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "Data Offset           : 0x{:08X}
BAT Offset            : {}
Header Version        : 0x{:08X}
Max Table Entries     : {}
Block Size            : 0x{:08X}",
            self.data_offset,
            self.bat_offset,
            self.header_version,
            self.max_table_entries,
            self.block_size
        )
    }
}

#[cfg(test)]
mod tests {
    use super::DynamicHeader;
    static HEADER: [u8; DynamicHeader::SIZE] = [
        0x63, 0x78, 0x73, 0x70, 0x61, 0x72, 0x73, 0x65, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
        0x10, 0x00, 0x00, 0x20, 0x00, 0x00, 0xff, 0xff, 0xf4, 0x67, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
    ];

    #[test]
    fn test_decode() {
        crate::tests_init();

        let dynheader = DynamicHeader::decode(&HEADER).unwrap();
        assert_eq!(dynheader.data_offset, 0xFFFFFFFFFFFFFFFFu64);
        assert_eq!(dynheader.bat_offset, 1536);
        assert_eq!(dynheader.header_version, 0x10000);
        assert_eq!(dynheader.max_table_entries, 4096);
        assert_eq!(dynheader.block_size, 0x200000);
        assert_eq!(dynheader.parent_unique_id, [0; 16]);
        assert_eq!(dynheader.parent_timestamp, 0);
        assert_eq!(dynheader.parent_unicode_name, [0; 512]);
        assert_eq!(dynheader.parent_locator_entry_1, [0; 24]);
        assert_eq!(dynheader.parent_locator_entry_2, [0; 24]);
        assert_eq!(dynheader.parent_locator_entry_3, [0; 24]);
        assert_eq!(dynheader.parent_locator_entry_4, [0; 24]);
        assert_eq!(dynheader.parent_locator_entry_5, [0; 24]);
        assert_eq!(dynheader.parent_locator_entry_6, [0; 24]);
        assert_eq!(dynheader.parent_locator_entry_7, [0; 24]);
        assert_eq!(dynheader.parent_locator_entry_8, [0; 24]);
        assert_eq!(dynheader.reserved2, [0; 256]);
    }

    #[test]
    fn test_encode() {
        crate::tests_init();
        let dynheader = DynamicHeader::decode(&HEADER).unwrap();
        let mut buffer = [0u8; DynamicHeader::SIZE];
        dynheader.encode(&mut buffer[..]);
        assert_eq!(buffer, HEADER);
    }
}
